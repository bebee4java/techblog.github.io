<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>tech-blog</title>
  
  <subtitle>技术总结、分享</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blogtech.top/"/>
  <updated>2019-10-08T11:04:47.914Z</updated>
  <id>https://blogtech.top/</id>
  
  <author>
    <name>bebee4java</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>docker常用操作及技巧</title>
    <link href="https://blogtech.top/2019/10/08/docker%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%8F%8A%E6%8A%80%E5%B7%A7/"/>
    <id>https://blogtech.top/2019/10/08/docker常用操作及技巧/</id>
    <published>2019-10-08T09:52:24.000Z</published>
    <updated>2019-10-08T11:04:47.914Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Dockerfile命令"><a href="#Dockerfile命令" class="headerlink" title="Dockerfile命令"></a>Dockerfile命令</h2><blockquote><p>官网介绍：<a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/builder/</a></p></blockquote><a id="more"></a><ol><li><p>FROM</p><p><code>FROM &lt;image&gt;:&lt;tag&gt;</code></p><p> 用于设置基础镜像，一般是Dockerfile的第一句。如果没有指定tag，则默认tag是latest。</p></li><li><p>MAINTAINER</p><p><code>MAINTAINER &lt;name&gt;</code></p><p>用来指定维护者的姓名和联系方式。</p></li><li><p>RUN</p><p><code>RUN &lt;command&gt; 或 RUN [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</code></p><p>每条 RUN 指令将在当前镜像基础上执行指定命令，并提交为新的镜像。</p></li><li><p>ADD</p><p><code>ADD &lt;src&gt; &lt;dest&gt;</code></p><p>将文件复制到文件：是相对被构建的源目录的相对路径，可以是文件或目录的路径，也可以是一个远程的文件 url，是容器中的绝对路径。</p></li><li><p>COPY</p><p><code>COPY &lt;src&gt; &lt;dest&gt;</code></p><p>复制本地主机的（为Dockerfile所在目录的相对路径）到容器中的,与ADD指令差不多</p></li><li><p>ENTRYPOINT</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [<span class="string">"executable"</span>,<span class="string">"param1"</span>,<span class="string">"param2"</span>] ：推荐使用的<span class="built_in">exec</span>形式</span><br><span class="line">ENTRYPOINT <span class="built_in">command</span> param1 param2 ：shell 形式</span><br></pre></td></tr></table></figure><p>配置容器启动后执行的命令，并且不可被 docker run 提供的参数覆盖。一个 Dockerfile 中只能有一个 ENTRYPOINT，如果有多个，则最后一个生效。</p></li><li><p>CMD</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CMD [<span class="string">"executable"</span>,<span class="string">"param1"</span>,<span class="string">"param2"</span>] 使用<span class="built_in">exec</span>执行，推荐方式；</span><br><span class="line">CMD <span class="built_in">command</span> param1 param2 在/bin/sh 中执行，提供给需要交互的应用；</span><br><span class="line">CMD [<span class="string">"param1"</span>,<span class="string">"param2"</span>]提供给ENTRYPOINT 的默认参数；</span><br></pre></td></tr></table></figure><p>指定启动容器时执行的命令，每个 Dockerfile 只能有一条 CMD 命令。如果指定了多条命令，只有最后一条会被执行。如果用户启动容器时候指定了运行的命令，则会覆盖掉 CMD 指定的命令。</p></li><li><p>WORKDIR</p><p><code>WORKDIR /path/to/workdir</code></p><p>为后续的 RUN、CMD、ENTRYPOINT 指令配置工作目录。可以使用多个 WORKDIR 指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。例如：<br>WORKDIR /a<br>WORKDIR b<br>WORKDIR c<br>RUN pwd<br>则最终路径为 /a/b/c 。</p></li><li><p>EXPOSE</p><p><code>EXPOSE &lt;port&gt; [&lt;port&gt;...]</code></p><p>告诉 Docker 服务端容器暴露的端口号，供互联系统使用。例如：EXPOSE 8080 3000，开放 8080 和 3000 端口。</p></li><li><p>ENV</p><p><code>ENV &lt;key&gt; &lt;value&gt;</code><br>指定一个环境变量，会被后续 RUN 指令使用，并在容器运行时保持。</p></li><li><p>VOLUME</p><p><code>VOLUME [&quot;/data&quot;]</code></p><p>创建一个可以从本地主机或其他容器挂载的挂载点，一般用来存放数据库和需要保持的数据等。</p></li><li><p>USER</p><p><code>USER &lt;UID/Username&gt;</code></p><p>为容器内指定 CMD RUN ENTRYPOINT 命令运行时的用户名或UID。</p></li></ol><h2 id="Docker常用命令"><a href="#Docker常用命令" class="headerlink" title="Docker常用命令"></a>Docker常用命令</h2><blockquote><p>官网介绍：<a href="https://docs.docker.com/engine/reference/commandline/docker/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/docker/</a></p></blockquote><h3 id="镜像相关"><a href="#镜像相关" class="headerlink" title="镜像相关"></a>镜像相关</h3><ol><li>查看本地仓库的镜像：<code>docker images</code></li><li>拉取远程仓库镜像：<code>docker pull REPOSITORY:TAG</code></li><li>将本地镜像推送到远程仓库：<code>docker push REPOSITORY:TAG</code><blockquote><p>一般需要三步：<br>A. 先将已有镜像打标签:<code>docker tag IMAGE_ID REPOSITORY:TAG</code> 需要tag为远程的仓库地址<br>B. 登录远程仓库：<code>docker login –username=USERNAME REPOSITORY_REGOIN</code><br>C. 推送镜像到远程仓库：<code>docker push REPOSITORY:TAG</code></p></blockquote></li><li>使用Dockerfile构建镜像: <code>docker build -t REPOSITORY:TAG .</code><blockquote><p>.点表示当前目录，默认会找当前目录下的Dockerfile进行构建，也可以通过<code>-f</code>指定Dockerfile：<code>docker build -f /path/Dockerfile -t REPOSITORY:TAG .</code></p></blockquote></li><li>删除镜像：<code>docker rmi IMAGE_ID/ REPOSITORY:TAG</code><blockquote><p>强制删除：<code>docker rmi -f IMAGE_ID</code></p></blockquote></li><li>删除untagged images：<code>docker rmi $(docker images | grep &quot;^&lt;none&gt;&quot; | awk &quot;{print $3}&quot;)</code></li><li>删除全部image：<code>docker rmi $(docker images -q)</code></li><li>删除所有不使用的镜像：<code>docker image prune --force --all</code> 或 <code>docker image prune -f -a</code></li></ol><h3 id="容器相关"><a href="#容器相关" class="headerlink" title="容器相关"></a>容器相关</h3><ol><li>查看正在运行的容器：<code>docker ps</code></li><li>列出所有容器ID：<code>docker ps -aq</code></li><li>查看正在运行容器的日志：<code>docker logs -f CONTAINER_ID</code></li><li>列出所有容器：<code>docker container list</code></li><li>停止容器：<code>docker stop CONTAINER_ID</code><blockquote><p>停止所有的container：<code>docker stop $(docker ps -a -q)</code></p></blockquote></li><li>删除容器：<code>docker rm CONTAINER_ID</code><blockquote><p>删除所有container：<code>docker rm $(docker ps -a -q)</code></p></blockquote></li><li>从容器到宿主机复制：<code>docker cp CONTAINER:SRC_PATH DEST_PATH</code></li><li>从宿主机到容器复制：<code>docker cp SRC_PATH CONTAINER:DEST_PATH</code></li><li>删除所有停止的容器：<code>docker container prune</code></li><li>停止/启动/杀死/重启一个容器：<code>docker stop/start/kill/restart CONTAINER_ID/CONTAINER_NAME</code></li><li>进入容器：<code>docker exec -it CONTAINER_ID /bin/bash</code><blockquote><p>docker exec ：在运行的容器中执行命令<br>-d :分离模式: 在后台运行<br>-i :即使没有附加也保持STDIN（标准输入） 打开,以交互运行容器，通常与 -t 同时使用；<br>-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；</p></blockquote></li><li>运行容器：<code>docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</code><blockquote><p>OPTIONS说明：<br>   -a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项；<br>   -d: 后台运行容器，并返回容器ID；<br>   -i: 以交互模式运行容器，通常与 -t 同时使用；<br>   -P: 随机端口映射，容器内部端口随机映射到主机的高端口<br>   -p: 指定端口映射，格式为：主机(宿主)端口:容器端口<br>   -t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；<br>   —name=”nginx-lb”: 为容器指定一个名称；<br>   —dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致；<br>   —dns-search example.com: 指定容器DNS搜索域名，默认和宿主一致；<br>   -h “mars”: 指定容器的hostname；<br>   -e username=”ritchie”: 设置环境变量；<br>   —env-file=[]: 从指定文件读入环境变量；<br>   —cpuset=”0-2” or —cpuset=”0,1,2”: 绑定容器到指定CPU运行；<br>   -m :设置容器使用内存最大值；<br>   —net=”bridge”: 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；<br>   —link=[]: 添加链接到另一个容器；<br>   —expose=[]: 开放一个端口或一组端口；<br>   —volume , -v: 绑定一个卷</p></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Dockerfile命令&quot;&gt;&lt;a href=&quot;#Dockerfile命令&quot; class=&quot;headerlink&quot; title=&quot;Dockerfile命令&quot;&gt;&lt;/a&gt;Dockerfile命令&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;官网介绍：&lt;a href=&quot;https://docs.docker.com/engine/reference/builder/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.docker.com/engine/reference/builder/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="docker" scheme="https://blogtech.top/categories/docker/"/>
    
    
      <category term="docker" scheme="https://blogtech.top/tags/docker/"/>
    
      <category term="虚拟化" scheme="https://blogtech.top/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>docker安装mysql搭建主从</title>
    <link href="https://blogtech.top/2019/10/07/docker%E5%AE%89%E8%A3%85mysql%E6%90%AD%E5%BB%BA%E4%B8%BB%E4%BB%8E/"/>
    <id>https://blogtech.top/2019/10/07/docker安装mysql搭建主从/</id>
    <published>2019-10-07T14:09:40.000Z</published>
    <updated>2019-10-07T15:50:28.848Z</updated>
    
    <content type="html"><![CDATA[<h2 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h2><p>docker search mysql:5.7</p><h2 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h2><p>docker pull mysql:5.7</p><a id="more"></a><h2 id="运行mysql容器"><a href="#运行mysql容器" class="headerlink" title="运行mysql容器"></a>运行mysql容器</h2><h3 id="建立配置文件"><a href="#建立配置文件" class="headerlink" title="建立配置文件"></a>建立配置文件</h3><p><img src="//blogtech.top/2019/10/07/docker安装mysql搭建主从/markdown-img-paste-20191007232046365.png" alt></p><h4 id="master配置文件"><a href="#master配置文件" class="headerlink" title="master配置文件"></a>master配置文件</h4><p>vim master/conf/my.cnf<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">server_id = 1</span><br><span class="line">log-bin= mysql-bin</span><br><span class="line">read-only=0</span><br><span class="line">replicate-ignore-db=mysql</span><br><span class="line">replicate-ignore-db=sys</span><br><span class="line">replicate-ignore-db=information_schema</span><br><span class="line">replicate-ignore-db=performance_schema</span><br></pre></td></tr></table></figure></p><h4 id="slave配置文件"><a href="#slave配置文件" class="headerlink" title="slave配置文件"></a>slave配置文件</h4><p>vim slave/conf/my.cnf<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">server_id = 2</span><br><span class="line">log-bin= mysql-bin</span><br><span class="line">log_slave_updates=1</span><br><span class="line">read-only=1</span><br><span class="line">replicate-ignore-db=mysql</span><br><span class="line">replicate-ignore-db=sys</span><br><span class="line">replicate-ignore-db=information_schema</span><br><span class="line">replicate-ignore-db=performance_schema</span><br></pre></td></tr></table></figure></p><blockquote><p>注：从库还需要添加一个参数：log-slave-updates，log-slave-updates参数默认是关闭的状态，如果不手动设置，那么bin-log只会记录直接在主库上执行的SQL语句，由replication机制的SQL线程读取relay-log而执行的SQL语句并不会记录到bin-log，那么就无法实现从库binlog的实时同步。</p></blockquote><h3 id="运行mysql-master"><a href="#运行mysql-master" class="headerlink" title="运行mysql-master"></a>运行mysql-master</h3><p>docker run —name mastermysql \<br>-p 3307:3306 \<br>-e MYSQL_ROOT_PASSWORD=123456 \<br>-v ~/opt/docker/mysql/master/data:/var/lib/mysql \<br>-v ~/opt/docker/mysql/master/conf/my.cnf:/etc/mysql/my.cnf \<br>-d mysql:5.7</p><h3 id="运行mysql-salve"><a href="#运行mysql-salve" class="headerlink" title="运行mysql-salve"></a>运行mysql-salve</h3><p>docker run —name slavemysql \<br>-p 3308:3306 \<br>-e MYSQL_ROOT_PASSWORD=123456 \<br>-v ~/opt/docker/mysql/slave/data:/var/lib/mysql \<br>-v ~/opt/docker/mysql/slave/conf/my.cnf:/etc/mysql/my.cnf \<br>-d mysql:5.7</p><h2 id="查看docker镜像运行情况"><a href="#查看docker镜像运行情况" class="headerlink" title="查看docker镜像运行情况"></a>查看docker镜像运行情况</h2><p>docker ps<br><img src="//blogtech.top/2019/10/07/docker安装mysql搭建主从/markdown-img-paste-20190926115002849.png" alt></p><h2 id="进入master容器"><a href="#进入master容器" class="headerlink" title="进入master容器"></a>进入master容器</h2><p>docker exec -it mastermysql bash</p><h2 id="进入mysql"><a href="#进入mysql" class="headerlink" title="进入mysql"></a>进入mysql</h2><p>root@a77371ae40bd:/# mysql -uroot -p123456</p><h2 id="查看master状态"><a href="#查看master状态" class="headerlink" title="查看master状态"></a>查看master状态</h2><p>mysql&gt; show master status;<br><img src="//blogtech.top/2019/10/07/docker安装mysql搭建主从/markdown-img-paste-20190926115058346.png" alt></p><h2 id="创建binlog用户，授权"><a href="#创建binlog用户，授权" class="headerlink" title="创建binlog用户，授权"></a>创建binlog用户，授权</h2><h3 id="创建binlog用户密码为binlog"><a href="#创建binlog用户密码为binlog" class="headerlink" title="创建binlog用户密码为binlog"></a>创建binlog用户密码为binlog</h3><p>CREATE USER ‘binlog’@’%’ IDENTIFIED BY ‘binlog’;</p><h3 id="授权binlog用户拥有binlog库所有表的所有权限"><a href="#授权binlog用户拥有binlog库所有表的所有权限" class="headerlink" title="授权binlog用户拥有binlog库所有表的所有权限"></a>授权binlog用户拥有binlog库所有表的所有权限</h3><p>GRANT ALL ON binlog.* TO ‘binlog’@’%’;</p><h3 id="授予用户-binlog-REPLICATION-SLAVE-权限和-REPLICATION-CLIENT-权限，用于在主从库之间同步数据。"><a href="#授予用户-binlog-REPLICATION-SLAVE-权限和-REPLICATION-CLIENT-权限，用于在主从库之间同步数据。" class="headerlink" title="授予用户 binlog REPLICATION SLAVE 权限和 REPLICATION CLIENT 权限，用于在主从库之间同步数据。"></a>授予用户 binlog REPLICATION SLAVE 权限和 REPLICATION CLIENT 权限，用于在主从库之间同步数据。</h3><p>GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO ‘binlog’@’%’;</p><h2 id="进入salve容器"><a href="#进入salve容器" class="headerlink" title="进入salve容器"></a>进入salve容器</h2><p>docker exec -it slavemysql bash</p><h2 id="在Slave中进入mysql，执行"><a href="#在Slave中进入mysql，执行" class="headerlink" title="在Slave中进入mysql，执行:"></a>在Slave中进入mysql，执行:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CHANGE MASTER TO master_host = &apos;172.17.0.2&apos;,</span><br><span class="line">master_user = &apos;binlog&apos;,</span><br><span class="line">master_password = &apos;binlog&apos;,</span><br><span class="line">master_port = 3306,</span><br><span class="line">master_log_file = &apos;mysql-bin.000003&apos;,</span><br><span class="line">master_log_pos = 154,</span><br><span class="line">master_connect_retry = 30;</span><br></pre></td></tr></table></figure><p><strong>注：</strong></p><blockquote><p>master_host ：Master 的地址，指的是容器的独立ip, 可以通过下面命令查询：</p> docker inspect --format='{{.NetworkSettings.IPAddress}}' 容器名称 | 容器id <p><img src="//blogtech.top/2019/10/07/docker安装mysql搭建主从/markdown-img-paste-20190926115222899.png" alt></p><p>master_port：Master 的端口号，指的是容器的端口号</p><p>master_user：用于数据同步的用户</p><p>master_password：用于同步的用户的密码</p><p>master_log_file：指定 Slave 从哪个日志文件开始复制数据，即上文中提到的 File 字段的值（主库记录的值）</p><p>master_log_pos：从哪个 Position 开始读，即上文中提到的 Position 字段的值（主库的pos值）</p><p>master_connect_retry：如果连接失败，重试的时间间隔，单位是秒，默认是 60 秒</p></blockquote><h2 id="查询主从同步状态"><a href="#查询主从同步状态" class="headerlink" title="查询主从同步状态:"></a>查询主从同步状态:</h2><p>show slave status \G;</p><p><img src="//blogtech.top/2019/10/07/docker安装mysql搭建主从/markdown-img-paste-20190926115401342.png" alt></p><h2 id="开启主从复制过程"><a href="#开启主从复制过程" class="headerlink" title="开启主从复制过程"></a>开启主从复制过程</h2><p>start slave;</p><p>再次查询主从同步状态 show slave status \G;<br><img src="//blogtech.top/2019/10/07/docker安装mysql搭建主从/markdown-img-paste-20190926115534116.png" alt></p><h2 id="在master库新建binlog库-mlsql-binlog表进行同步测试："><a href="#在master库新建binlog库-mlsql-binlog表进行同步测试：" class="headerlink" title="在master库新建binlog库 mlsql_binlog表进行同步测试："></a>在master库新建binlog库 mlsql_binlog表进行同步测试：</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> <span class="keyword">binlog</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="keyword">binlog</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`mlsql_binlog`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`log`</span> <span class="built_in">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">`mlsql_binlog`</span> (<span class="string">`id`</span>, <span class="string">`log`</span>) <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">'hello'</span>);</span><br></pre></td></tr></table></figure><blockquote><p>友情链接：<a href="https://learnku.com/articles/30439" target="_blank" rel="noopener">https://learnku.com/articles/30439</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;查看镜像&quot;&gt;&lt;a href=&quot;#查看镜像&quot; class=&quot;headerlink&quot; title=&quot;查看镜像&quot;&gt;&lt;/a&gt;查看镜像&lt;/h2&gt;&lt;p&gt;docker search mysql:5.7&lt;/p&gt;&lt;h2 id=&quot;拉取镜像&quot;&gt;&lt;a href=&quot;#拉取镜像&quot; class=&quot;headerlink&quot; title=&quot;拉取镜像&quot;&gt;&lt;/a&gt;拉取镜像&lt;/h2&gt;&lt;p&gt;docker pull mysql:5.7&lt;/p&gt;
    
    </summary>
    
    
      <category term="docker" scheme="https://blogtech.top/categories/docker/"/>
    
    
      <category term="docker" scheme="https://blogtech.top/tags/docker/"/>
    
      <category term="虚拟化" scheme="https://blogtech.top/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://blogtech.top/2019/09/27/hello-world/"/>
    <id>https://blogtech.top/2019/09/27/hello-world/</id>
    <published>2019-09-27T10:12:53.966Z</published>
    <updated>2019-09-27T10:12:53.967Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
</feed>
