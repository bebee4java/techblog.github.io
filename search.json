[{"title":"git常用操作与技巧","url":"/2020/03/30/git常用操作与技巧/","content":"\n\ngit pull <远程主机名> <远程分支名>:<本地分支名>\n如拉取远程的master分支到本地wy分支：\ngit pull origin master:wy\n"},{"title":"发布自己的项目JAR到MAVEN中央仓库","url":"/2019/12/30/发布自己的项目JAR到MAVEN中央仓库/","content":"## 为什么写这篇文章\n&emsp;&emsp;maven是java世界最流行的构建工具，做java的程序员应该没少使用maven中央仓库中的各种jar包，方便解决了工作中很多问题，提高了编码效率。程序员界有个编程原则就是：不要重复造轮子，所以工作中时常会抽取出很多实用的工具类、包等等。但是咱们也不能总是只取不予，应该懂得奉献，当你写好了一个十分好用的jar包，想贡献出去给大家使用的时候，应该怎么做呢？方法就是发布到maven的中央仓库，别人就可以通过maven依赖引用。不过这个发布过程，还是比较复杂的，本文就来详细说下如何发布自己的jar包到maven的中央仓库。\n## 发布到中央仓库的好处\n&emsp;&emsp;首先，作为一个java从业者，对天天在用的东西，做一个深入的了解，学会发布一个项目到中央仓库。对于我来讲，往maven发布自己的项目，开始有了利用下班时间好好写点开源代码学习和装逼的冲动。其次前面说到程序绝对不要重复造轮子，我在做开源项目[SQLPower](https://github.com/bebee4java/sqlpower)和[SQLAlarm](https://github.com/bebee4java/sqlalarm)的时候有很多公用的util类需要抽取成common模块，比较好的做法就是新建一个[common-utils](https://github.com/bebee4java/common-utils)项目，把所有公共的代码放在这项目中，然后发布到maven仓库里。如此一来另外两个项目就都可以通过maven依赖使用了。这样既方便了自己也往maven仓库中贡献了自己的代码，有可能别人通过你的项目也能提供效率。利人利己的事情还是很值得大家去尝试实践的。\n## 发布流程\n&emsp;&emsp;在发布前,您需要有自己的项目主页并开源的代码,您可以使用GitHub或者gitlab,下面的内容以GitHub为例。\n### 注册 sonatype的Jira帐号\n注册地址: https://issues.sonatype.org/secure/Signup!default.jspa\n\n注册很简单,重要的是邮箱地址一定要正确,issue有任何变动都会通过邮件通知.\n> 这里要着重说明一下: Username字段一定要使用英文+数字,一定不要使用中文!!!否则官方无法分配权限给你，会让你另行注册。\n注册完成后你会收到官方给你的一份邮件：\n![signup](发布自己的项目JAR到MAVEN中央仓库/signup.png)\n\n### 登录Jira\n注册完成后登陆: https://issues.sonatype.org/login.jsp\n### 创建一个 Issue\n> 通过【Create】按钮创建\n![new_issue](发布自己的项目JAR到MAVEN中央仓库/new_issue.png)\n> Project选择【Community Support - Open Source Project Repository Hosting (OSSRH)】\n> Issue Type: 选择【New Project】\n> Summary和Description: 自己填,注意要用英文\n> Group Id: 这个必须要注意,如果你用的是GitHub,一定要是 com.github.你的github用户名,例如我的项目地址是:https://github.com/bebee4java/common-utils, 那我的groupId就是com.github.bebee4java, 当然也可以使用 GitHub的Page的域名 io.github.你的github用户名. 如果你有自己的域名和项目地址也可以,官方人员会询问你是否有这个域名的所有权.在你项目的pom里一定要使用这个groupId,最好包路径也使用.\n> Project URL: 是你的项目地址\n> SCM url: 是你的项目git地址\n> Username(s): 可以不用填,这是能辅助你提交项目的合作人的帐号,前提是他也得在这个Jira注册\n> 其他使用默认值就行了\n![](发布自己的项目JAR到MAVEN中央仓库/issue.png)\n创建好Issue后就等待官方回复吧。这个需要一段时间的等待，运气好的话很快就会有工作人员回复你。\n\n这边我使用自己的域名作为项目的Group Id。然后工作人员给我回复了这么一个问题：\n![](发布自己的项目JAR到MAVEN中央仓库/oss-domain.png)\nCentral OSSRH 问你，这个域名是你的么，怎么证明这个域名是你的呢？他给了你两种解决方法。\n1. 在域名解析中加上一个Txt记录，指向你发布的这个Issues(他称作JIRA ticket:)。（最快）\n2. 设置重定向到您的Github页面（如果尚不存在）\n\n所以，我选择了第一种方式，在dns里加条txt记录：\n![](发布自己的项目JAR到MAVEN中央仓库/dns.png)\n然后你就可以继续等待他的回复了......看到他给你这么回复：\n![](发布自己的项目JAR到MAVEN中央仓库/domain-ok.png)\n说明你的问题被解决了：\n![](发布自己的项目JAR到MAVEN中央仓库/issue-ok.png)\n审批通过在你申请的邮件箱中也会收到通过的邮件。\n\n### 配置gpg加密jar包上传到构件仓库里面\n1. 安装gpg: Mac直接在控制台`brew install gpg`即可.\n> Windows 系统，可以下载 Gpg4win 软件来生成密钥对。\n> 下载地址：https://www.gpg4win.org/download.html\n> 查看是否安装成功: gpg --version\n2. 命令行生成生成秘钥: `gpg --gen-key`\n按提示输入名字， 如：bebee4java，邮箱grsong.cn@gmail,com，然后选择(O)kay, 输入：o\n![](发布自己的项目JAR到MAVEN中央仓库/gen-key.png)\n然后要求输入密码Passphase（输入两次），相当于密钥库密码，不要忘记。\n![](发布自己的项目JAR到MAVEN中央仓库/passphase.png)\n到此密钥就生成成功了。\n3. 查看公钥: `gpg --list-keys`\n![](发布自己的项目JAR到MAVEN中央仓库/list_keys.png)\n在框选的位置，会面需要用到。\n4. 将公钥发布到 PGP 密钥服务器: `gpg --keyserver hkp://keyserver.ubuntu.com:11371 --send-keys 你的公钥`\n![](发布自己的项目JAR到MAVEN中央仓库/send-keys.png)\n5. 查询是否上报成功: `gpg --keyserver hkp://keyserver.ubuntu.com:11371 --recv-keys 你的公钥`\n如果出现下面，别急再试一次就ok了：\n![](发布自己的项目JAR到MAVEN中央仓库/recv-keys-err.png)\n输出下面信息说明发布成功了：\n![](发布自己的项目JAR到MAVEN中央仓库/recv-keys-ok.png)\n\n### 配置maven setting.xml\n```xml\n<servers>\n    <server>\n        <id>sonatype-nexus-snapshots</id>\n        <username>sonatype用户名</username>\n        <password>sonatype密码</password>\n    </server>\n    <server>\n        <id>sonatype-nexus-staging</id>\n        <username>sonatype用户名</username>\n        <password>sonatype密码</password>\n    </server>\n</servers>\n\n...\n\n<profiles>\n    <profile>\n        <id>nexus-ossrh</id>\n        <activation>\n            <activeByDefault>true</activeByDefault>\n        </activation>\n\n        <properties>\n            <gpg.executable>gpg</gpg.executable>\n            <gpg.passphrase>密钥的密码</gpg.passphrase>\n        </properties>\n    </profile>\n</profiles>\n```\n> server的id随意填写，只要和项目的pom.xml里面对应就行了。\n\n### 配置项目pom.xml\n```xml\n<name>common utils</name>\n<url>https://github.com/bebee4java/common-utils</url>\n<description>\n    A common util library for the sqlclub projects\n</description>\n<licenses>\n    <license>\n        <name>Apache 2.0 License</name>\n        <url>http://www.apache.org/licenses/LICENSE-2.0.html</url>\n        <distribution>repo</distribution>\n    </license>\n</licenses>\n<developers>\n    <developer>\n        <id>bebee4java</id>\n        <name>songgongru</name>\n        <email>grsong.cn@gmail.com</email>\n    </developer>\n</developers>\n<scm>\n    <connection>\n        scm:git:git@github.com:bebee4java/common-utils.git\n    </connection>\n    <developerConnection>\n        scm:git:git@github.com:bebee4java/common-utils.git\n    </developerConnection>\n    <url>https://github.com/bebee4java/common-utils</url>\n</scm>\n<issueManagement>\n    <url>https://github.com/bebee4java/common-utils/issues</url>\n</issueManagement>\n<profiles>\n  <profile>\n    <id>release-sign-artifacts</id>\n    <build>\n        <plugins>\n            <!-- GPG -->\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-gpg-plugin</artifactId>\n                <version>1.6</version>\n                <executions>\n                    <execution>\n                        <phase>verify</phase>\n                        <goals>\n                            <goal>sign</goal>\n                        </goals>\n                    </execution>\n                </executions>\n            </plugin>\n        </plugins>\n    </build>\n    <distributionManagement>\n        <snapshotRepository>\n            <id>sonatype-nexus-snapshots</id>\n            <url>https://oss.sonatype.org/content/repositories/snapshots/</url>\n        </snapshotRepository>\n        <repository>\n            <id>sonatype-nexus-staging</id>\n            <url>https://oss.sonatype.org/service/local/staging/deploy/maven2/</url>\n        </repository>\n    </distributionManagement>\n  </profile>\n</profiles>\n<build>\n   <plugins>\n      <plugin>\n         <groupId>org.sonatype.plugins</groupId>\n         <artifactId>nexus-staging-maven-plugin</artifactId>\n         <version>1.6.7</version>\n         <extensions>true</extensions>\n         <configuration>\n            <serverId>sonatype-nexus-staging</serverId>\n            <nexusUrl>https://oss.sonatype.org/</nexusUrl>\n            <autoReleaseAfterClose>true</autoReleaseAfterClose>\n         </configuration>\n      </plugin>\n   </plugins>\n</build>\n```\n> 注意：distributionManagement->repository->id 要和maven setting.xml 中的保持一致。\n\n### 上传构件到OSS中\n\n```bash\nmvn clean deploy -Prelease-sign-artifacts\n```\n> 如果出现错误：gpg: signing failed: Inappropriate ioctl for device\n在~/.zshrc 文件里加入export GPG_TTY=$(tty)\n\n打包过程中会让你输入PGP的密码：\n![](发布自己的项目JAR到MAVEN中央仓库/gpg-pass.png)\n出现下面上传的信息，说明你已经可以正常将jar包部署到 OSS 中。\n![](发布自己的项目JAR到MAVEN中央仓库/deploy-jar.png)\n注意：此时上传的构件并未正式发布到中央仓库中，只是部署到 OSS 中了，别人还不能够使用。\n\n### 在OSS中发布构建\n&emsp;&emsp;地址：https://oss.sonatype.org/#stagingRepositories 需要使用之前注册的sonatype账号登录。\n\n&emsp;&emsp;用你的SonaType的账号密码进行登陆后，点击左边的Staging Repositories然后根据所写的Group Id进行查询。如果在Staging Repositories中查找不到你的项目，但是在[Nexus公有库](https://oss.sonatype.org/index.html)中是可以查找到你的项目的话。那么这个问题可以忽略，因为这个是nexus-staging-maven-plugin插件中autoReleaseAfterClose自动设置为了True，所以就自动给close->release->drop三步，相当于自动给你做了。所以等待两个小时就会在中央仓库查找到了。\n![](发布自己的项目JAR到MAVEN中央仓库/nexus-repo.png)\n\n### 通知Sonatype构件已成功发布\n&emsp;&emsp;通知Sonatype构件已成功发布，在之前创建的Issue中回复一条`The component has been successfully released`通知工作人员为需要发布的构件做审批，发布后会关闭该Issue。\n\n**遇到的坑：**\n\n&emsp;&emsp;当第一次进行上传的时候，version不要写成SNAPSHOT的，如果你写成SNAPSHOT版本的话，那么Sonartype管理员会回复你下面一段话：\n![](发布自己的项目JAR到MAVEN中央仓库/snapshot-problem.png)\n大概意思是在第一次的时候不能上传SNAPSHOT只有第一次成功了以后才可上传。\n\n解决方法：修改version重新deploy。很快管理员就回复同步已经开启：\n![](发布自己的项目JAR到MAVEN中央仓库/central-sync.png)\n看到整个同步过程需要2个小时左右，还是挺慢的😂......\n\n## 检查同步是否成功\n&emsp;&emsp;除了通过 [search.maven.org](https://search.maven.org/) 检查同步是否成功之外，查询[mvnrepository](https://mvnrepository.com/search?q=tech.sqlclub)也是常用的搜索方式。不过，值得一提的是，mvnrepository 相较于 search.maven.org 同步会更慢点，原因是 mvnrepository 引用了 central.maven.org 仓库。而 `central.maven.org == repo1.maven.org`，两个域名对应的 IP 是一样的，而这个 repo1.maven.org 就是默认的 Maven central repository，也就是 search.maven.org 的仓库。所以，你可以在以下两个仓库看到发布包：\nhttp://central.maven.org/maven2/tech/sqlclub/\nhttp://repo1.maven.org/maven2/tech/sqlclub/\n\n&emsp;&emsp;据我实际测试发现，大概release之后不超过20分钟，就可以在\nhttps://repo.maven.apache.org/maven2/ 这里查看到了，\n只要这里有了，别人就可以依赖你提供的这个jar了。\n\n## 以后发布过程\n&emsp;&emsp;第一次提交才这么麻烦,以后提交只用重复maven发布,当然需要等待大概2小时的时间。\n如果要发布新的项目,在使用相同GroupId的情况下,与上面的过程一样。只有使用不同的GroupId的时候,才会需要再去提交Issue申请。\n&emsp;&emsp;当然如果你没有换电脑的话 GPG 的过程只需要一次就行。\n","tags":["Java","工作技能"],"categories":["工作技能"]},{"title":"Java设计模式:策略模式","url":"/2019/10/22/Java设计模式-策略模式/","content":"## 策略模式简介\n### 定义\n> Define a family of algorithms, encapsulate each one, and make them interchangeable. [The] Strategy [pattern] lets the algorithm vary independently from clients that use it.\n\n策略模式定义了一组算法，将它们逐个封装起来，并使它们可以相互替换。策略可以让算法独立于使用它们的客户而变化。\n\n### 模式结构\n策略模式包含如下角色：\n- Context：上下文类，持有具体策略类的实例，并负责调用相关的算法\n- Strategy：策略接口或者策略抽象类\n- ConcreateStrategyA等：实现策略接口的具体策略类\n\n类图：\n![](Java设计模式-策略模式/类图.png)\n时序图：\n![](Java设计模式-策略模式/时序图.png)\n\n### 使用场景\n在以下情况下可以使用策略模式：\n\n- 如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。\n- 一个系统需要动态地在几种算法中选择一种。\n- 如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。\n- 不希望客户端知道复杂的、与算法相关的数据结构，在具体策略类中封装算法和相关的数据结构，提高算法的保密性与安全性。\n\n## 实践一下\n上面分析了策略模式的结构和概念，介绍了使用的场景。不过光看这些概念还是有些空洞，不好理具体的实现逻辑。下面我将以具体的实例来说明，加深大家对策略模式的理解。\n\n紧张的期末考试结束了，班主任想看下同学们的语文成绩的排名情况，如果让你来实现这个需求会怎么做呢？很自然的首先我们需要定义学生这个对象，包含学号、语文成绩等等属性，那要怎么对Student对象进行排序呢？我们知道Java对象要想进行大小比较，可以实现Comparable接口，实现里面的compareTo方法，这样就可以对两个学生对象进行比较了。于是学生类可以这么实现：\n```java\npublic class Student implements Comparable<Student> {\n    // 学号\n    int sid;\n    // 语文成绩\n    int chinese;\n    // 数学成绩\n    int math;\n\n    public Student(int sid, int chinese, int math) {\n        this.sid = sid;\n        this.chinese = chinese;\n        this.math = math;\n    }\n    public int compareTo(Student o) {\n        if (this.chinese > o.chinese) return 1;\n        else if (this.chinese < o.chinese) return -1;\n        else return 0;\n    }\n    @Override\n    public String toString() {\n        return \"{sid:\"+sid+\",chinese:\"+chinese+\",math:\"+math+\"}\";\n    }\n}\n```\n定义好学生对象后，我们就可以实现一个Sorter，对学生对象进行排序了，sort方法(V1)可以这么做（这里可以忽略排序的算法，重点是在说明策略模式）：\n```java\n// 只能对student进行排序\n    public void sort_v1(Student[] arr) {\n        for (int i=0; i<arr.length-1; i++){\n            int minPos = i;\n            for (int j=i+1; j<arr.length; j++){\n                minPos = arr[j].compareTo(arr[minPos]) == -1 ? j : minPos;\n            }\n            swap(arr, i, minPos);\n        }\n    }\n    void swap(Student[] arr, int i, int j) {\n        Student temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n```\n我们对上面功能进行测试：\n```java\npublic class SortApp {\n    public static void main(String[] args) {\n       Student[] arr = {new Student(1, 90, 100),\n               new Student(2, 80, 89),\n               new Student(3, 91, 90)\n       };\n\n       Sorter sorter = new Sorter();\n       sorter.sort(arr);\n       System.out.println(Arrays.toString(arr));\n    }\n}\n```\n执行代码，输出下面结果：\n```java\n[{sid:2,chinese:80,math:89}, {sid:1,chinese:90,math:100}, {sid:3,chinese:91,math:90}]\n```\n可以看到Student已经按照chinese成绩进行升序排列了，很好到此已经完全实现了班主任交给你的需求了。\n第二天，班主任又找到了你说，想了解一下自己班级在整个年级的语文成绩排名情况。对于班级如何衡量语文成绩的水平呢？我们可以采用语文成绩的平均分进行排序。由上面的经验，先定义Class对象，包含班级编号、语文成绩等等属性：\n```java\npublic class Class implements Comparable<Class> {\n    // 班级编号\n    int cid;\n    // 语文平均成绩\n    int chinese;\n    // 数学平成绩\n    int math;\n\n    public Class(int cid, int chinese, int math) {\n        this.cid = cid;\n        this.chinese = chinese;\n        this.math = math;\n    }\n    public int compareTo(Class o) {\n        if (this.chinese > o.chinese) return 1;\n        else if (this.chinese < o.chinese) return -1;\n        else return 0;\n    }\n    @Override\n    public String toString() {\n        return \"{cid:\"+cid+\",chinese:\"+chinese+\",math:\"+math+\"}\";\n    }\n}\n```\n为了能复用之前的Sorter我们对sort方法进行改造，让其既能对Student排序，也能对Class排序：\n```java\n// 能对所有的Comparable对象进行排序, 但是比较方法不能修改\n    public void sort(Comparable[] arr) {\n        for (int i=0; i<arr.length-1; i++){\n            int minPos = i;\n            for (int j=i+1; j<arr.length; j++){\n                minPos = arr[j].compareTo(arr[minPos]) == -1 ? j : minPos;\n            }\n            swap(arr, i, minPos);\n        }\n    }\n    void swap(Comparable[] arr, int i, int j) {\n        Comparable temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n```\n很好，此时的Sorter可以对任意可比较的对象（实现了Comparable接口）进行排序了。\n\n到这Sorter已经完美了嘛？聪明的你应该已经发现了，学生不仅有语文成绩，还有数学成绩等等。如果班主任哪天想看一下学生的数学成绩排名怎么办？你可能想到的方式是把Student的compareTo方法重写一下啊，让它按照数学成绩进行比较。这确实能够实现，但是这种方式不是一种好的写法。因为班主任的想法可能经常会变，你不可能每次都来修改Student类，这不符合开闭原则。\n\n好的做法是，我们可以定义几种比较的策略，每次可以根据班主任的要求来选择策略进行排序，而不是来修改Student对象。可以通过Java的Comparator接口来实现，所以最终的Sorter实现是：\n```java\nclass Sorter<T> {\n    public void sort(T[] arr, Comparator<T> comparator) {\n        for (int i=0; i<arr.length-1; i++){\n            int minPos = i;\n            for (int j=i+1; j<arr.length; j++){\n                minPos = comparator.compare(arr[j],arr[minPos]) == -1 ? j : minPos;\n            }\n            swap(arr, i, minPos);\n        }\n    }\n    void swap(T[] arr, int i, int j) {\n        T temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n}\n```\n这样我们就可以对Student灵活的根据语文、数学成绩进行排序了：\n```java\nStudent[] arr = {new Student(1, 90, 100),\n                new Student(2, 80, 89),\n                new Student(3, 91, 90)\n        };\nnew Sorters<Student>().sort(arr, new Comparator<Student>() {\n            public int compare(Student o1, Student o2) {\n                if (o1.chinese > o2.chinese) return 1;\n                else if (o1.chinese < o2.chinese) return -1;\n                else return 0;\n            }\n        });\n```\n看到这你是否能想起来？哦！Java的Collections工具类的sort不就这么干的嘛。我们来看个例子：\n```java\nList<Integer> list = new ArrayList<Integer>();\nlist.add(3);list.add(1);list.add(2);\nCollections.sort(list, new Comparator<Integer>() {\n    public int compare(Integer o1, Integer o2) {\n        if (o1 > o2) return 1;\n        else if (o1 < o2) return -1;\n        else return 0;\n    }\n});\nSystem.out.println(list);\n```\n其实这就是采用了策略模式。\n\n## 总结\n策略模式提供了对“开闭原则”的完美支持，用户可以在不修改原有系统的基础上选择算法（策略），并且可以灵活地增加新的算法（策略）。可以避免使用多重条件转移语句。\n不过缺点就是客户端必须知道所有的策略类，并自行决定使用哪一个策略类。为了更好的组织所有的策略我们可以通过枚举来扩展：\n```java\nenum StudentStrategyEnum {\n    CHINESE {\n        @Override\n        public Comparator strategy(){\n          return new Comparator<Student>(){\n              public int compare (Student o1, Student o2){\n                  if (o1.chinese > o2.chinese) return 1;\n                  else if (o1.chinese < o2.chinese) return -1;\n                  else return 0;\n              }\n          };\n      }\n    },\n\n    MATH {\n        @Override\n        public Comparator strategy(){\n            return new Comparator<Student>(){\n                public int compare (Student o1, Student o2){\n                    if (o1.math > o2.math) return 1;\n                    else if (o1.math < o2.math) return -1;\n                    else return 0;\n                }\n            };\n        }\n    };\n\n    public abstract Comparator strategy();\n}\n```\n我们就可以这么来选择排序策略：\n```java\nnew Sorters<Student>().sort(arr, StudentStrategyEnum.MATH.strategy());\n```\n其实StudentStrategyEnumme枚举类本身也采用了策略模式。麻雀虽小，五脏俱全。策略模式的几个要素，在策略枚举里都能找到。首先是Strategy接口，这里由抽象的strategy方法充当。而ConcreteStrategy则由枚举值CHINESE、MATH充当。Context则是枚举类本身，通过枚举类选择不同的枚举值也就相当于选择不同的策略(算法)。\n\n> 源码地址：https://github.com/bebee4java/java-design-patterns/tree/master/strategy","tags":["设计模式","Java"],"categories":["设计模式"]},{"title":"Java设计模式:单例模式","url":"/2019/10/17/Java设计模式-单例模式/","content":"## 单例模式简介\n### 定义\n保证一个类仅有一个实例，并提供一个访问它的全局访问入口。（你是我的唯一～～）\n### 为什么要用单例模式呢？\n&emsp;&emsp;其实生活中很多地方可以反应单例模式：比如一个国家只有一个总统；你正常合法的老婆只能有一个，别人叫你老婆时必须只能是同一个人（排除违法搞多个）。\n\n&emsp;&emsp;在软件系统中，有一些对象其实我们只需要一个比如：线程池、缓存、注册表、日志对象、充当打印机、显卡等设备驱动程序的对象等。事实上，这一类对象也只能有一个实例，如果制造出多个实例就可能会导致一些问题的产生，比如：程序的行为异常、资源使用过量、或者不一致性的结果等。\n\n&emsp;&emsp;一个简单场景就是：我们的应用程序有一些配置文件，我们希望只在系统启动的时候读取这些配置文件，并将这些配置保存在内存中，以后在程序中使用这些配置文件信息的时候不必再重新读取。这时候就需要使用单例模式。\n\n&emsp;&emsp;一般在下面两种场景下会考虑使用单例模式：\n1. 产生某对象会消耗过多的资源，为避免频繁地创建与销毁对象对资源的浪费。如：\n> 对数据库的操作、访问 IO、线程池（threadpool）、网络请求等。\n2. 某种类型的对象应该有且只有一个。如果制造出多个这样的实例会使程序异常。如：\n> 一个系统只能有：一个窗口管理器或文件系统，计时工具或 ID（序号）生成器，缓存（cache），处理偏好设置和注册表（registry）的对象，日志对象。\n\n&emsp;&emsp;简单来说使用单例模式可以带来下面几个好处：\n1. 对于频繁使用的对象，可以节省创建对象所花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销；\n2. 由于new操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻 GC 压力，缩短 GC 停顿时间。\n\n## 实现方式\n&emsp;&emsp;单例模式，按加载时机可以分为：饿汉方式和懒汉方式；按实现的方式，有：双重检查加锁，内部类方式和枚举方式等等。它们有的效率很高，有的节省内存，有的实现得简单漂亮，还有的存在严重缺陷，大部分使用的时候都有限制条件。下面我们来分析下各种写法的区别，辨别哪些是不可行的，哪些是推荐的，最后为大家筛选出几个值得我们适时应用到项目中的实现方式。\n\n### 饿汉模式\n&emsp;&emsp;所谓饿汉模式就是指全局的单例实例在类装载时构建。举个生活例子：妈妈早上起来为我们做饭吃，饭快做好的时候，一般都会叫我们起床吃饭，这是日常情况。如果饭还没有好的时候，我们就自己起来了（这时候妈妈还没有叫我们起床），这种情况在单例模式中称之为饿汉式，也就是说妈妈还没有叫我们起床，我们自己就起来的，就是外部还没有调用自己，自己的实例就已经创建好了。\n\n<details>\n```java\npublic class HungryPresident {\n\n    private static final HungryPresident INSTANCE = new HungryPresident();\n\n    // 私有化构造方法\n    private HungryPresident(){\n\n    }\n\n    public static HungryPresident getInstance() {\n        System.out.println(\"getInstance\");\n        return INSTANCE;\n    }\n}\n```\n**优缺点：**\n1. 简单实用，比较推荐。\n2. 类加载到内存后，只实例化一个实例，JVM保证线程安全，不用同步，运行效率高。\n3. 实例不管后续有没有使用，类加载完就完成实例化，外部一直没有调用该实例，那么这部分的系统资源的消耗是没有意义的。但话说如果这个类不用的话，你也没必要加载呀。\n\n> 代码测试验证：\n> ![](Java设计模式-单例模式/markdown-img-paste-20191021154529932.png)\n\n### 懒汉模式\n&emsp;&emsp;所谓的懒汉模式，就是一开始并不实例化对象，等到需要使用的时候才实例化。还是上面的例子，如果饭做好了，妈妈叫我们起床之后，我们才慢吞吞的起床，这种情况在单例模式中称之为懒汉式（饭都做好了，妈妈叫你起床之后，自己才起的，能不懒汉吗？就是外部对该类的方法发出调用之后，该实例才建立的）。\n<details>\n```java\npublic class LazyLoadPresident {\n\n    private static LazyLoadPresident INSTANCE;\n\n    private LazyLoadPresident() {\n\n    }\n\n    public static LazyLoadPresident getInstance() {\n\n        if (INSTANCE == null) {\n            System.out.println(\"getInstance\");\n            INSTANCE = new LazyLoadPresident();\n        }\n\n        return INSTANCE;\n    }\n}\n```\n**优缺点：**\n1. 实例在被使用的时候才被创建，可以节省系统资源，体现了延迟加载的思想。\n2. 多线程下，实例不能保证只有一个，线程不安全。\n\n> 代码测试验证：\n> ![](Java设计模式-单例模式/markdown-img-paste-20191021153411447.png)\n\n<font color=red>那如何将懒汉式单例在多线程下正确的发挥作用呢？</font>\n\n可以在访问单例实例的方法处进行同步：\n<details>\n```java\npublic class ThreadSafeLazyLoadPresident {\n\n    private static ThreadSafeLazyLoadPresident INSTANCE;\n\n    private ThreadSafeLazyLoadPresident() {\n\n    }\n\n    public static synchronized ThreadSafeLazyLoadPresident getInstance() {\n        if (INSTANCE == null) {\n            System.out.println(\"getInstance\");\n            INSTANCE = new ThreadSafeLazyLoadPresident();\n        }\n        return INSTANCE;\n    }\n}\n```\n**优缺点：**\n1. 可以正确按需返回单例对象，线程安全\n2. 每次获取对象都得加锁，在频繁获取对象操作下，效率太低\n\n> 代码测试验证：\n> ![](Java设计模式-单例模式/markdown-img-paste-20191021202039812.png)\n\n### 双重检查加锁式\n&emsp;&emsp;上面懒汉模式直接在整个方法用了synchronized关键字进行方法同步，锁的粒度太大。双重校验方式就是为了解决懒汉模式的线程安全和效率问题而产生的。\n<details>\n```java\npublic class ThreadSafeDoubleCheckPresident {\n\n    // 必须加volatile\n    private static volatile ThreadSafeDoubleCheckPresident INSTANCE;\n\n    private ThreadSafeDoubleCheckPresident() {\n\n    }\n\n    public static ThreadSafeDoubleCheckPresident getInstance() {\n        if (INSTANCE == null) {  // 这层判断是有必要的 大多数情况下INSTANCE不为null直接返回了，减少了加锁的操作\n            System.out.println(\"getInstance\");\n            synchronized (ThreadSafeDoubleCheckPresident.class) {\n                if (INSTANCE == null) {\n                    INSTANCE = new ThreadSafeDoubleCheckPresident();\n                }\n            }\n        }\n\n        return INSTANCE;\n    }\n\n}\n```\n> 注：\n> 下面解释一下为啥 instance 变量要声明成 volatile\n> 原因是instance = new ThreadSafeDoubleCheckPresident() 这一行代码并不是原子性的，具体来说，JVM执行这一行代码时主要做了三件事：\n> 1.给 instance 分配内存空间\n> 2.调用 ThreadSafeDoubleCheckPresident 的构造函数来初始化成员变量\n> 3.将 instance 变量指向分配的内存空间（执行完这一步之后 instance 就不为 null 了）\n> 由于 JVM 的指令优化存在，上面的第二点和第三点并不能保证一定按顺序执行。也就是说执行顺序有可能为 1-2-3 或者 1-3-2\n> 假设是 1-3-2，那么如果执行到3的时候，线程被抢占了，有另外一个线程获取了单例对象（这时候 instance 不为 null，但是还没有初始化），那么自然就会出现错误。\n> 为了解决这个问题，我们只要将 instance 变量声明成 volatile 就可以了。\n> volatile 关键字主要有两个特性：\n> 1.可见性：保证线程没有变量的本地副本，每次都去主内存获取最新版本\n> 2.禁止指令重排序：生成内存屏障\n> 很明显，我们这里利用的是 volatile 的第二个特性。\n> 特别注意的是只有在 Java 5 之后使用这种方式才是完全安全的，原因是 Java 5 之前的 Java 内存模型（Java Memory Model，JMM）存在缺陷，即使变量声明为 volatile 也不能完全避免重排序，这个问题在 Java 5 之后才修复。\n\n**优缺点：**\n1. 可以正确按需返回单例对象，线程安全\n2. 不够简洁，不好理解\n\n### 静态内部类式\n&emsp;&emsp;静态内部实现的单例是懒加载的且线程安全。根据JVM的类加载规则，静态内部类只有在主动调用的时候才会加载。也就是说，在第一次调用 getInstance() 方法时才会加载 SingletonHolder 类，同时创建了 INSTANCE 对象。\n<details>\n```java\npublic class InitializingOnDemandHolderPresident {\n\n    private InitializingOnDemandHolderPresident(){\n\n    }\n\n    // 可以做到延迟加载\n    private static class SingletonHolder {\n        private static final InitializingOnDemandHolderPresident INSTANCE =\n                new InitializingOnDemandHolderPresident();\n    }\n\n    public static InitializingOnDemandHolderPresident getInstance() {\n        return SingletonHolder.INSTANCE;\n    }\n\n}\n```\n**优缺点：**\n1. 懒加载的且线程安全，解决占用内存问题\n2. 无法阻止反射、序列化攻击\n\n### 枚举类式\n&emsp;&emsp;这种实现方式没有被广泛采用，但这是实现单例模式的最佳方法。 它更简洁，自动支持序列化机制，绝对防止多次实例化。其实上面所说的实现方式都存在缺陷，就是无法阻止通过反射、序列化的方式创建出多个实例，只有枚举这种形式可以做到。\n<details>\n```java\npublic enum  EnumPresident {\n    INSTANCE;\n\n    public void run(){\n        System.out.println(\"EnumPresident run ...\");\n    }\n\n}\n```\n**优缺点：**\n1. 简洁、线程安全、绝对单例\n2. 把一个类定义成枚举形式上有点别扭\n\n## 总结\n文章主要介绍到了以下几种方式实现单例模式：\n- 饿汉式(线程安全）\n- 懒汉式（非线程安全和synchronized关键字线程安全版本)\n- 懒汉式(双重检查加锁版本)\n- 懒汉式（静态内部类方式）\n- 饿汉式（枚举方式）\n\nJDK中也有相同方式的单例实现类如：\n- java.lang.Runtime.getRuntime()\n- java.awt.Desktop.getDesktop()\n- java.lang.System.getSecurityManager()\n\n每种方式都存在优缺点，值得一说的是，绝大部分场景中直接使用第一种饿汉式就可以，它足够简单，也能保证线程安全，只要你可以容忍它在第一次创建所消耗的系统资源。\n> 源码地址：https://github.com/bebee4java/java-design-patterns/tree/master/singleton\n","tags":["设计模式","Java"],"categories":["设计模式"]},{"title":"Java设计模式剖析","url":"/2019/10/11/Java设计模式剖析/","content":"&emsp;&emsp;一直想写介绍设计模式的文章，让读者可以很快看完，而且一看就懂，看懂就会用，同时不会将各个模式搞混。当然这个需要有一定的编程经验才能做到。自己虽然不够nb，但也积累了一些经验，是时候写点东西了，也算是自我的总结。所以文中可能也存在一些纰漏，欢迎大家留言指正。\n\n&emsp;&emsp;设计模式（Design pattern）是一套应该被反复使用的代码设计经验的总结。使用设计模式是为了可复用代码、让代码更易理解、保证代码的可靠性。\n\n&emsp;&emsp;我知道大家（包括我在内）在写代码的时候可能不会那么刻意的去使用一些设计模式，但是它绝对是值得你去思考并使用的一套理论。项目中合理的运用设计模式可以完美的解决很多问题，并使你走向优秀代码的道路。\n\n&emsp;&emsp;我接下来的几篇文章会以理论与实践相结合的方式来进行总结，希望广大程序爱好者和我一起，学好设计模式，做一个优秀的软件工程师！\n\n## 设计模式六大原则\n学习设计模式之前最好先了解一下设计模式的设计原则：\n1. 开闭原则（open close principle）\n  开放即指对扩展开放，对修改关闭。简而言之，就是扩展功能的时候应该尽量的不修改原有的代码。\n2. 里氏代换原则（liskov substitution principle）\n  可以理解为派生类与基类的替换关系，是对\"开-闭\"原则的补充。通俗来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。\n3. 依赖倒转原则（dependence inverse principle）\n  这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。目的是通过要面向接口的编程来降低类间的耦合性。符合高内聚低耦合原则。\n4. 接口隔离原则（Interface Segregation Principle）\n  使用多个隔离的接口，比使用单个接口要好，核心就是控制类的粒度大小、将对象解耦、提高其内聚性。\n5. 迪米特法则，又称最少知道原则（Demeter Principle）\n  一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。降低类之间的耦合度，提高了模块的相对独立性。\n6. 合成复用原则（Composite Reuse Principle）\n  尽量使用合成/聚合的方式，而不是使用继承。\n\n## 设计模式类型\n&emsp;&emsp;根据设计模式的参考书[Design Patterns - Elements of Reusable Object-Oriented Software](DesignPatterns.pdf)（中文译名：设计模式 - 可复用的面向对象软件元素，由GOF四人帮合著） 中所提到的，总共有 23 种设计模式。这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。\n### 创建型模式\n隐藏创建对象的创建逻辑，提供创建对象的接口，而非使用new关键字进行创建。\n* [单例模式（Singleton Pattern）](/2019/10/17/Java设计模式-单例模式/)\n* 工厂模式（Factory Pattern）\n* 抽象工厂模式（Abstract Factory Pattern）\n* 建造者模式（Builder Pattern）\n* 原型模式（Prototype Pattern）\n\n### 结构型模式\n这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。\n* 适配器模式（Adapter Pattern）\n* 桥接模式（Bridge Pattern）\n* 过滤器模式（Filter、Criteria Pattern）\n* 组合模式（Composite Pattern）\n* 装饰器模式（Decorator Pattern）\n* 外观模式（Facade Pattern）\n* 享元模式（Flyweight Pattern）\n* 代理模式（Proxy Pattern）\n\n### 行为型模式\n这些设计模式特别关注对象之间的通信。\n* 责任链模式（Chain of Responsibility Pattern）\n* 命令模式（Command Pattern）\n* 解释器模式（Interpreter Pattern）\n* 迭代器模式（Iterator Pattern）\n* 中介者模式（Mediator Pattern）\n* 备忘录模式（Memento Pattern）\n* 观察者模式（Observer Pattern）\n* 状态模式（State Pattern）\n* 空对象模式（Null Object Pattern）\n* 策略模式（Strategy Pattern）\n* 模板模式（Template Pattern）\n* 访问者模式（Visitor Pattern）\n\n设计模式之间的关系可以用下图整体描述：\n![](Java设计模式剖析/markdown-img-paste-2019101121061240.png)\n\n&emsp;&emsp;该文主要介绍一些基本概念和理论知识，后续文章会结合代码的形式详细介绍每种设计模式使用方式，如果你着急关注实际的使用，也可以跳转某一种设计模式单独了解，不必要按顺序阅读。\n","tags":["设计模式","Java"],"categories":["设计模式"]},{"title":"conda使用技巧总结","url":"/2019/10/10/conda使用技巧总结/","content":"## 创建环境\n创建一个名为py35的环境，指定Python版本是3.5（不用管是3.5.x，conda会为我们自动寻找3.５.x中的最新版本）\n```python\nconda create --name py35 python=3.5\n```\n\n## 激活环境\n激活py35环境\n```python\nsource activate py35\n```\n\n## 返回主环境\n```python\nsource deactivate py35\n```\n\n## 删除环境\n删除一个已有的环境\n```python\nconda remove --name py35 --all\n```\n\n## 查看系统中的所有环境\n```python\nconda info -e\n```\n\n## 安装库\n```python\nconda install numpy\n```\n\n## 查看已经安装的库\n```python\nconda list\n```\n\n## 搜索package的信息\n```python\nconda search numpy\n```\n\n## 安装package到指定的环境\n如果不用-n指定环境名称，则被安装在当前活跃环境，也可以通过-c指定通过某个channel安装\n```python\nconda install -n py35 numpy\n```\n\n## 更新package\n```python\nconda update -n py35 numpy\n```\n\n## 删除package\n```python\nconda remove -n py35 numpy\n```\n\n## 设置国内镜像，加速conda\n在User主目录下生成.condarc文件，删掉channels下面的 -defaults一行,使其不再访问默认channel\n```python\nconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/\n\nconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/\n\nconda config --set show_channel_urls yes\n```\n","tags":["python"],"categories":["python"]},{"title":"mysql创建用户与授权","url":"/2019/10/09/mysql创建用户与授权/","content":"## 创建用户\n```sql\nCREATE USER 'username'@'host' IDENTIFIED BY 'password';\n```\n> 说明:\n> username：你将创建的用户名\n> host：指定该用户在哪个主机上可以登陆，如果是本地用户可用localhost，如果想让该用户可以从任意远程主机登陆，可以使用通配符`%`\n> password：该用户的登陆密码，密码可以为空，如果为空则该用户可以不需要密码登陆服务器\n> 例子：\n```sql\nCREATE USER 'pig'@'localhost' IDENTIFIED BY '123456';\nCREATE USER 'pig'@'%' IDENTIFIED BY '123456';\nCREATE USER 'pig'@'%' IDENTIFIED BY '';\nCREATE USER 'pig'@'%';\n```\n\n## 用户授权\n```sql\nGRANT privileges ON databasename.tablename TO 'username'@'host'\n```\n> 说明：\n> privileges：用户的操作权限，如SELECT，INSERT，UPDATE等，如果要授予所的权限则使用ALL\n> databasename：数据库名\n> tablename：表名，如果要授予该用户对所有数据库和表的相应操作权限则可用`*`表示，如`*.*`\n> 例子：\n```sql\nGRANT SELECT, INSERT ON test.user TO 'pig'@'%';\nGRANT ALL ON *.* TO 'pig'@'%';\nGRANT ALL ON test.* TO 'pig'@'%';\n```\n> **注意：**\n> 用以上命令授权的用户不能给其它用户授权，如果想让该用户可以授权，用以下命令:\n```sql\nGRANT privileges ON databasename.tablename TO 'username'@'host' WITH GRANT OPTION;\n```\n\n## 设置或更改用户密码\n```sql\nSET PASSWORD FOR 'username'@'host' = PASSWORD('newpassword');\n```\n> 如果是当前登陆用户用:\n```sql\nSET PASSWORD = PASSWORD(\"newpassword\");\n```\n> 例子：\n```sql\nSET PASSWORD FOR 'pig'@'%' = PASSWORD(\"123456\");\nSET PASSWORD = PASSWORD(\"123456\");\n```\n\n## 撤销用户权限\n```sql\nREVOKE privilege ON databasename.tablename FROM 'username'@'host';\n```\n>具体信息可以用命令查看:\n```sql\nSHOW GRANTS FOR 'username'@'host';\n```\n\n## 删除用户\n```sql\nDROP USER 'username'@'host';\n```\n\n> 友情链接：https://www.cnblogs.com/sos-blue/p/6852945.html\n","tags":["数据库","mysql"],"categories":["mysql"]},{"title":"docker安装mysql搭建主从","url":"/2019/10/08/docker安装mysql搭建主从/","content":"## 查看镜像\ndocker search mysql:5.7\n## 拉取镜像\ndocker pull mysql:5.7\n## 运行mysql容器\n### 建立配置文件\n![](docker安装mysql搭建主从/markdown-img-paste-20191007232046365.png)\n#### master配置文件\nvim master/conf/my.cnf\n```\n[mysqld]\nserver_id = 1\nlog-bin= mysql-bin\nread-only=0\nreplicate-ignore-db=mysql\nreplicate-ignore-db=sys\nreplicate-ignore-db=information_schema\nreplicate-ignore-db=performance_schema\n```\n#### slave配置文件\nvim slave/conf/my.cnf\n```\n[mysqld]\nserver_id = 2\nlog-bin= mysql-bin\nlog_slave_updates=1\nread-only=1\nreplicate-ignore-db=mysql\nreplicate-ignore-db=sys\nreplicate-ignore-db=information_schema\nreplicate-ignore-db=performance_schema\n```\n> 注：从库还需要添加一个参数：log-slave-updates，log-slave-updates参数默认是关闭的状态，如果不手动设置，那么bin-log只会记录直接在主库上执行的SQL语句，由replication机制的SQL线程读取relay-log而执行的SQL语句并不会记录到bin-log，那么就无法实现从库binlog的实时同步。\n\n### 运行mysql-master\ndocker run --name mastermysql \\\n-p 3307:3306 \\\n-e MYSQL_ROOT_PASSWORD=123456 \\\n-v ~/opt/docker/mysql/master/data:/var/lib/mysql \\\n-v ~/opt/docker/mysql/master/conf/my.cnf:/etc/mysql/my.cnf \\\n-d mysql:5.7\n\n### 运行mysql-salve\ndocker run --name slavemysql \\\n-p 3308:3306 \\\n-e MYSQL_ROOT_PASSWORD=123456 \\\n-v ~/opt/docker/mysql/slave/data:/var/lib/mysql \\\n-v ~/opt/docker/mysql/slave/conf/my.cnf:/etc/mysql/my.cnf \\\n-d mysql:5.7\n\n## 查看docker镜像运行情况\ndocker ps\n![](docker安装mysql搭建主从/markdown-img-paste-20190926115002849.png)\n## 进入master容器\ndocker exec -it mastermysql bash\n## 进入mysql\nroot@a77371ae40bd:/# mysql -uroot -p123456\n## 查看master状态\nmysql> show master status;\n![](docker安装mysql搭建主从/markdown-img-paste-20190926115058346.png)\n\n## 创建binlog用户，授权\n### 创建binlog用户密码为binlog\nCREATE USER 'binlog'@'%' IDENTIFIED BY 'binlog';\n### 授权binlog用户拥有binlog库所有表的所有权限\nGRANT ALL ON binlog.* TO 'binlog'@'%';\n### 授予用户 binlog REPLICATION SLAVE 权限和 REPLICATION CLIENT 权限，用于在主从库之间同步数据。\nGRANT REPLICATION SLAVE, REPLICATION CLIENT ON \\*.\\* TO 'binlog'@'%';\n## 进入salve容器\ndocker exec -it slavemysql bash\n## 在Slave中进入mysql，执行:\n```\nCHANGE MASTER TO master_host = '172.17.0.2',\nmaster_user = 'binlog',\nmaster_password = 'binlog',\nmaster_port = 3306,\nmaster_log_file = 'mysql-bin.000003',\nmaster_log_pos = 154,\nmaster_connect_retry = 30;\n```\n\n**注：**\n>master_host ：Master 的地址，指的是容器的独立ip, 可以通过下面命令查询：\n\n>{%raw%} docker inspect --format='{{.NetworkSettings.IPAddress}}' 容器名称 | 容器id {%endraw%}\n\n>![](docker安装mysql搭建主从/markdown-img-paste-20190926115222899.png)\n\n>master_port：Master 的端口号，指的是容器的端口号\n\n>master_user：用于数据同步的用户\n\n>master_password：用于同步的用户的密码\n\n>master_log_file：指定 Slave 从哪个日志文件开始复制数据，即上文中提到的 File 字段的值（主库记录的值）\n\n>master_log_pos：从哪个 Position 开始读，即上文中提到的 Position 字段的值（主库的pos值）\n\n>master_connect_retry：如果连接失败，重试的时间间隔，单位是秒，默认是 60 秒\n\n## 查询主从同步状态:\nshow slave status \\G;\n\n![](docker安装mysql搭建主从/markdown-img-paste-20190926115401342.png)\n\n## 开启主从复制过程\nstart slave;\n\n再次查询主从同步状态 show slave status \\G;\n![](docker安装mysql搭建主从/markdown-img-paste-20190926115534116.png)\n\n## 在master库新建binlog库 mlsql_binlog表进行同步测试：\n<details>\n```sql\ncreate database binlog;\n\nuse binlog;\n\nCREATE TABLE `mlsql_binlog` (\n  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,\n  `log` varchar(200) DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) CHARSET=utf8;\n\ninsert into `mlsql_binlog` (`id`, `log`) values(1, 'hello');\n```\n> 友情链接：https://learnku.com/articles/30439\n","tags":["docker","虚拟化"],"categories":["docker"]},{"title":"docker常用操作及技巧","url":"/2019/10/07/docker常用操作及技巧/","content":"## Dockerfile命令\n> 官网介绍：https://docs.docker.com/engine/reference/builder/\n\n1. FROM\n\n   `FROM <image>:<tag>`\n\n    用于设置基础镜像，一般是Dockerfile的第一句。如果没有指定tag，则默认tag是latest。\n2. MAINTAINER\n\n   `MAINTAINER <name>`\n\n   用来指定维护者的姓名和联系方式。\n3. RUN\n\n   `RUN <command> 或 RUN [\"executable\",\"param1\",\"param2\"]`\n\n   每条 RUN 指令将在当前镜像基础上执行指定命令，并提交为新的镜像。\n4. ADD\n\n   `ADD <src> <dest>`\n\n   将文件复制到文件：src是相对被构建的源目录（执行docker build命令的当前目录）的相对路径，可以是文件或目录的路径，也可以是一个远程的文件 url，dest是容器中的绝对路径。\n\n5. COPY\n\n   `COPY <src> <dest>`\n\n   复制本地主机的src到容器中的dest,与ADD指令差不多\n\n6. ENTRYPOINT\n\n   ```bash\n   ENTRYPOINT [\"executable\",\"param1\",\"param2\"] ：推荐使用的exec形式\n   ENTRYPOINT command param1 param2 ：shell 形式\n   ```\n\n   配置容器启动后执行的命令，并且不可被 docker run 提供的参数覆盖。一个 Dockerfile 中只能有一个 ENTRYPOINT，如果有多个，则最后一个生效。\n\n7. CMD\n   ```bash\n   CMD [\"executable\",\"param1\",\"param2\"] 使用exec执行，推荐方式；\n   CMD command param1 param2 在/bin/sh 中执行，提供给需要交互的应用；\n   CMD [\"param1\",\"param2\"]提供给ENTRYPOINT 的默认参数；\n   ```\n\n   指定启动容器时执行的命令，每个 Dockerfile 只能有一条 CMD 命令。如果指定了多条命令，只有最后一条会被执行。如果用户启动容器时候指定了运行的命令，则会覆盖掉 CMD 指定的命令。\n\n8. WORKDIR\n\n   `WORKDIR /path/to/workdir`\n\n   为后续的 RUN、CMD、ENTRYPOINT 指令配置工作目录。可以使用多个 WORKDIR 指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。例如：\n   WORKDIR /a\n   WORKDIR b\n   WORKDIR c\n   RUN pwd\n   则最终路径为 /a/b/c 。\n\n9. EXPOSE\n\n   `EXPOSE <port> [<port>...]`\n\n   告诉 Docker 服务端容器暴露的端口号，供互联系统使用。例如：EXPOSE 8080 3000，开放 8080 和 3000 端口。\n\n10. ENV\n\n    `ENV <key> <value>`\n    指定一个环境变量，会被后续 RUN 指令使用，并在容器运行时保持。\n\n11. VOLUME\n\n    `VOLUME [\"/data\"]`\n\n    创建一个可以从本地主机或其他容器挂载的挂载点，一般用来存放数据库和需要保持的数据等。\n\n12. USER\n\n    `USER <UID/Username>`\n\n    为容器内指定 CMD RUN ENTRYPOINT 命令运行时的用户名或UID。\n\n## Docker常用命令\n> 官网介绍：https://docs.docker.com/engine/reference/commandline/docker/\n\n### 镜像相关\n1. 查看本地仓库的镜像：`docker images`\n2. 拉取远程仓库镜像：`docker pull REPOSITORY:TAG`\n3. 本地镜像打标记：\n`docker tag IMAGE[:TAG] [REGISTRYHOST/][USERNAME/]NAME[:TAG]`\n4. 使用Dockerfile构建镜像: `docker build -t REPOSITORY:TAG .`\n> .点表示当前目录，默认会找当前目录下的Dockerfile进行构建，也可以通过`-f`指定Dockerfile：`docker build -f /path/Dockerfile -t REPOSITORY:TAG .`\n5. 将本地镜像推送到远程仓库：`docker push REPOSITORY:TAG`\n> 一般需要三步：\n> A. 先将已有镜像打标签:`docker tag IMAGE_ID REPOSITORY:TAG` 需要tag为远程的仓库地址\n> B. 登录远程仓库：`docker login –username=USERNAME REPOSITORY_REGOIN`\n> C. 推送镜像到远程仓库：`docker push REPOSITORY:TAG`\n>\n> 比如将hello-docker:v1推送到docker hub库：\n> docker push hub.docker.com/r/bebee/demo/hello-docker:v1\n> docker镜像库：\n> docker hub：https://hub.docker.com\n> 网易云镜像中心：https://c.163yun.com/hub#/m/home/\n6. 删除镜像：`docker rmi IMAGE_ID/ REPOSITORY:TAG`\n> 强制删除：`docker rmi -f IMAGE_ID`\n7. 删除untagged images：`docker rmi $(docker images | grep \"^<none>\" | awk \"{print $3}\")`\n8. 删除全部image：`docker rmi $(docker images -q)`\n9. 删除所有不使用的镜像：`docker image prune --force --all` 或 `docker image prune -f -a`\n\n镜像操作流程示意图：\n![镜像操作流程示意图](docker常用操作及技巧/markdown-img-paste-20191212230950631.png)\n\n### 容器相关\n1. 查看正在运行的容器：`docker ps`\n2. 列出所有容器ID：`docker ps -aq`\n3. 查看正在运行容器的日志：`docker logs -f CONTAINER_ID`\n4. 列出所有容器：`docker container list`\n5. 停止容器：`docker stop CONTAINER_ID`\n> 停止所有的container：`docker stop $(docker ps -a -q) `\n6. 删除容器：`docker rm CONTAINER_ID`\n> 删除所有container：`docker rm $(docker ps -a -q)`\n7. 从容器到宿主机复制：`docker cp CONTAINER:SRC_PATH DEST_PATH`\n8. 从宿主机到容器复制：`docker cp SRC_PATH CONTAINER:DEST_PATH`\n9. 删除所有停止的容器：`docker container prune`\n10. 停止/启动/杀死/重启一个容器：`docker stop/start/kill/restart CONTAINER_ID/CONTAINER_NAME`\n11. 进入容器：`docker exec -it CONTAINER_ID /bin/bash`\n> docker exec ：在运行的容器中执行命令\n> -d :分离模式: 在后台运行\n> -i :即使没有附加也保持STDIN（标准输入） 打开,以交互运行容器，通常与 -t 同时使用；\n> -t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；\n12. 运行容器：`docker run [OPTIONS] IMAGE [COMMAND] [ARG...]`\n> OPTIONS说明：\n>\t-a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项；\n>\t-d: 后台运行容器，并返回容器ID；\n>\t-i: 以交互模式运行容器，通常与 -t 同时使用；\n>\t-P: 随机端口映射，容器内部端口随机映射到主机的高端口\n>\t-p: 指定端口映射，格式为：主机(宿主)端口:容器端口\n>\t-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；\n>\t--name=\"nginx-lb\": 为容器指定一个名称；\n>\t--dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致；\n>\t--dns-search example.com: 指定容器DNS搜索域名，默认和宿主一致；\n>\t-h \"mars\": 指定容器的hostname；\n>\t-e username=\"ritchie\": 设置环境变量；\n>\t--env-file=[]: 从指定文件读入环境变量；\n>\t--cpuset=\"0-2\" or --cpuset=\"0,1,2\": 绑定容器到指定CPU运行；\n>\t-m :设置容器使用内存最大值；\n>\t--net=\"bridge\": 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；\n>\t--link=[]: 添加链接到另一个容器；\n>\t--expose=[]: 开放一个端口或一组端口；\n>\t--volume , -v: 绑定一个卷\n","tags":["docker","虚拟化"],"categories":["docker"]},{"title":"Hello World","url":"/2019/09/27/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n"}]